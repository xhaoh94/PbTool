using System.Text.Json.Serialization;
using System.Text.RegularExpressions;

namespace PbTool
{
    [Pb("ts")]
    internal class PbTs : PbBase
    {
        struct PbTsJson
        {
            [JsonPropertyName("csToMessage")]
            [JsonInclude]
            public Dictionary<int, string> CSToMessage;
            [JsonPropertyName("scToMessage")]
            [JsonInclude]
            public Dictionary<int, string> SCToMessage;
            [JsonPropertyName("bcstToMessage")]
            [JsonInclude]
            public Dictionary<int, string> BCSTToMessage;
            [JsonPropertyName("messageData")]
            [JsonInclude]
            public Dictionary<string, List<List<string>>> MessageData;
        }
        Regex CS = new Regex(@"(//(cs|CS)=)(?<cmd>([1-9][0-9]*))(message )(?<title>(\w|_)+)");
        Regex SC = new Regex(@"(//(sc|SC)=)(?<cmd>([1-9][0-9]*))(message )(?<title>(\w|_)+)");
        Regex BCST = new Regex(@"(//(BCST|bcst)=)(?<cmd>([1-9][0-9]*))(message )(?<title>(\w|_)+)");
        Regex Message = new Regex(@"(message )(?<title>(\w|_)+)({)(?<context>[\w|\s|;|=]*)(})");
        Regex Enum = new Regex(@"(enum )(?<title>(\w|_)+)({)(?<context>[\w|\s|;|=]+)(})");
        Regex Context = new Regex(@"(?<left>(\w|_|\s)+)(=)(?<right>(\d)+)(;)");

        [JsonPropertyName("createjson")]
        [JsonInclude]
        public bool CreateJson = true;

        [JsonPropertyName("usemodule")]
        [JsonInclude]
        public bool UseModule = true;


        Dictionary<WriteData, Dictionary<int, string>> cmdToFile = new Dictionary<WriteData, Dictionary<int, string>>();
        Dictionary<string, string> titleToFile = new Dictionary<string, string>();
        HashSet<string> EnumHash = new HashSet<string>();
        protected override void OnCreateCmd()
        {

        }

        protected override bool OnParse()
        {
            var files = GetProtoFiles();
            if (files == null)
            {
                Program.LogError("没有找到Proto文件");
                return false;
            }
            var csWd = new WriteData();
            var scWd = new WriteData();
            var bcstWd = new WriteData();
            csWd.Writeln(@"// Generated by https://github.com/xhaoh94/PbTool");
            csWd.Writeln(@"// DO NOT EDIT!");
            scWd.Writeln(@"// Generated by https://github.com/xhaoh94/PbTool");
            scWd.Writeln(@"// DO NOT EDIT!");
            bcstWd.Writeln(@"// Generated by https://github.com/xhaoh94/PbTool");
            bcstWd.Writeln(@"// DO NOT EDIT!");
            if (UseModule)
            {
                csWd.Write($"export ");
                scWd.Write($"export ");
                bcstWd.Write($"export ");
            }

            csWd.Write($"namespace {Program.NameSpace}");
            scWd.Write($"namespace {Program.NameSpace}");
            bcstWd.Write($"namespace {Program.NameSpace}");


            csWd.StartBlock();
            scWd.StartBlock();
            bcstWd.StartBlock();

            csWd.Write("export const enum CS");
            scWd.Write("export const enum SC");
            bcstWd.Write("export const enum BCST");

            csWd.StartBlock();
            scWd.StartBlock();
            bcstWd.StartBlock();
            Dictionary<string, List<List<string>>> map = new Dictionary<string, List<List<string>>>();
            Dictionary<int, string> csMap = new Dictionary<int, string>();
            Dictionary<int, string> scMap = new Dictionary<int, string>();
            Dictionary<int, string> bcstMap = new Dictionary<int, string>();
            foreach (var file in files)
            {
                var str = File.ReadAllText(file);
                ParseCMD(file, str, CS, csWd, csMap);
                ParseCMD(file, str, SC, scWd, scMap);
                ParseCMD(file, str, BCST, bcstWd, bcstMap);
                ParseMeesage(file, str, map);
            }
            csWd.EndBlock();
            scWd.EndBlock();
            bcstWd.EndBlock();


            csWd.EndBlock();
            scWd.EndBlock();
            bcstWd.EndBlock();

            csWd.Export(OutPath, "CS.ts");
            scWd.Export(OutPath, "SC.ts");
            bcstWd.Export(OutPath, "BCST.ts");

            if (CreateJson)
            {
                var jobj = new PbTsJson();
                jobj.CSToMessage = csMap;
                jobj.SCToMessage = scMap;
                jobj.BCSTToMessage = bcstMap;
                jobj.MessageData = map;
                var str = System.Text.Json.JsonSerializer.Serialize(jobj);
                WriteJson(str);
            }
            else
            {
                WriteWd(csMap, "CSToMessage", "CSToMessage");
                WriteWd(scMap, "SCToMessage", "SCToMessage");
                WriteWd(bcstMap, "BCSTToMessage", "BCSTToMessage");
                WriteMessageMd(map, "MessageData", "MessageData");
            }

            return true;
        }
        void WriteJson(string str)
        {
            var wd = new WriteData();
            wd.Writeln(@"// Generated by https://github.com/xhaoh94/PbTool");
            wd.Writeln(@"// DO NOT EDIT!");
            if (UseModule)
            {
                wd.Write($"export ");
            }
            wd.Write($"namespace {Program.NameSpace}");
            wd.StartBlock();
            wd.Write($"export interface Dpdts");
            wd.StartBlock();
            wd.Writeln("csToMessage?: { [key: number]: string };");
            wd.Writeln("scToMessage?: { [key: number]: string };");
            wd.Writeln("bcstToMessage?: { [key: number]: string };");
            wd.Writeln("messageData?: { [key: string]: string[][] };");
            wd.EndBlock();
            wd.EndBlock();
            wd.Export(OutPath, "Dpdts.ts");

            var wdjson = new WriteData();
            wdjson.Write(str);
            wdjson.Export(OutPath, "Dpdts.json");
        }
        void WriteWd(Dictionary<int, string> map, string clsName, string fileName)
        {
            var wd = new WriteData();
            
            wd.Writeln(@"// Generated by https://github.com/xhaoh94/PbTool");
            wd.Writeln(@"// DO NOT EDIT!");
            if (UseModule)
            {
                wd.Write($"export ");
            }
            wd.Write($"namespace {Program.NameSpace}");
            wd.StartBlock();
            wd.Write($"export const {clsName}: {{ [key: number]: string }}=");
            wd.StartBlock();
            foreach (var kv in map)
            {
                wd.Writeln($"{TsParse.GetString(kv.Key)}:{TsParse.GetString(kv.Value)}");
            }
            wd.EndBlock();
            wd.EndBlock();
            wd.Export(OutPath, fileName + ".ts");
        }
        void WriteMessageMd(Dictionary<string, List<List<string>>> map, string clsName, string fileName)
        {
            var wd = new WriteData();
            wd.Writeln(@"// Generated by https://github.com/xhaoh94/PbTool");
            wd.Writeln(@"// DO NOT EDIT!");
            if (UseModule)
            {
                wd.Write($"export ");
            }
            wd.Write($"namespace {Program.NameSpace}");
            wd.StartBlock();
            wd.Write($"export const {clsName}: {{ [key: string]: string[][] }}=");
            wd.StartBlock();
            var cnt1 = map.Count;
            for (int i = 0; i < cnt1; i++)
            {
                var kv = map.ElementAt(i);
                wd.Write($"{TsParse.GetString(kv.Key)}: [");
                var cnt2 = kv.Value.Count;
                for (int i2 = 0; i2 < cnt2; i2++)
                {
                    var listData = kv.Value[i2];
                    wd.Write("[", false);
                    for (int i3 = 0; i3 < listData.Count; i3++)
                    {
                        wd.Write(TsParse.GetString(listData[i3]), false);
                        if (i3 < listData.Count - 1)
                        {
                            wd.Write(",", false);
                        }
                    }
                    if (i2 == cnt2 - 1)
                    {
                        wd.Write($"]", false);
                    }
                    else
                    {
                        wd.Write($"],", false);
                    }
                }
                if (i == cnt1 - 1)
                {
                    wd.Writeln($"]", false);
                }
                else
                {
                    wd.Writeln($"],", false);
                }
            }
            wd.EndBlock();
            wd.EndBlock();
            wd.Export(OutPath, fileName + ".ts");
        }
        bool ParseCMD(string file, string str, Regex regex, WriteData wd, Dictionary<int, string> map)
        {
            str = str.Replace("\r", "");
            str = str.Replace("\n", "");
            var matches = regex.Matches(str);
            foreach (Match match in matches)
            {
                var cmd = int.Parse(match.Groups["cmd"].Value);
                if (!cmdToFile.TryGetValue(wd, out var dict))
                {
                    dict = new Dictionary<int, string>();
                    cmdToFile.Add(wd, dict);
                }
                if (dict.TryGetValue(cmd, out var temFile))
                {
                    Console.WriteLine("CMD定义重复存在");
                    Console.WriteLine("proto1:" + temFile);
                    Console.WriteLine("proto2:" + file);
                    return false;
                }
                var title = match.Groups["title"].Value;
                wd.Writeln($"{title} = {cmd},");
                dict[cmd] = file;
                map[cmd] = title;
            }
            return true;
        }
        void ParseMeesage(string file, string str, Dictionary<string, List<List<string>>> map)
        {
            str = str.Replace("\r", "");
            str = str.Replace("\n", "");
            var tsWd = new WriteData();
            if (UseModule)
            {
                tsWd.Write($"export ");
            }
            tsWd.Write($"namespace {Program.NameSpace}");
            tsWd.StartBlock();
            if (!ParseEnum(file, str, tsWd))
            {
                return;
            }
            if (!ParseMessage(file, str, tsWd, map))
            {
                Program.LogError("解析消息体错误");
                return;
            }
            tsWd.EndBlock();

            var exportFile = GetFileName(file, out var dirName);
            Console.WriteLine(exportFile);
            tsWd.Export($"{OutPath}/{dirName}", $"{exportFile}.ts");
        }
        public string GetFileName(string filePath, out string dirName)
        {
            filePath = filePath.Replace("\\", "/");
            filePath = filePath.Replace(InPath + "/", "");
            var index = filePath.LastIndexOf(".");
            filePath = filePath.Substring(0, index);
            index = filePath.LastIndexOf("/");
            if (index == -1)
            {
                dirName = string.Empty;
            }
            else
            {
                dirName = filePath.Substring(0, index);
                filePath = filePath.Substring(index + 1);
            }
            return filePath;
        }
        bool ParseEnum(string file, string str, WriteData wd)
        {
            var matches = Enum.Matches(str);
            foreach (Match match in matches)
            {
                var title = match.Groups["title"].Value;
                if (titleToFile.TryGetValue(title, out var temFile))
                {
                    Console.WriteLine("枚举定义重复存在");
                    Console.WriteLine("proto1:" + temFile);
                    Console.WriteLine("proto2:" + file);
                    return false;
                }
                EnumHash.Add(title);
                titleToFile[title] = file;
                var context = match.Groups["context"].Value;
                wd.Write($"export const enum {title}");
                wd.StartBlock();
                var contextMatches = Context.Matches(context);
                foreach (Match contextMatch in contextMatches)
                {
                    var left = contextMatch.Groups["left"].Value.TrimStart().TrimEnd();
                    var right = contextMatch.Groups["right"].Value;
                    wd.Writeln($"{left} = {right},");
                }
                wd.EndBlock();
            }
            return true;
        }

        bool ParseMessage(string file, string str, WriteData wd, Dictionary<string, List<List<string>>> map)
        {
            var matches = Message.Matches(str);
            foreach (Match match in matches)
            {
                var title = match.Groups["title"].Value;
                if (titleToFile.TryGetValue(title, out var temFile))
                {
                    Console.WriteLine("消息体定义重复存在");
                    Console.WriteLine("proto1:" + temFile);
                    Console.WriteLine("proto2:" + file);
                    return false;
                }
                titleToFile[title] = file;
                var context = match.Groups["context"].Value;
                wd.Write($"export interface {title}");
                wd.StartBlock();
                var contextMatches = Context.Matches(context);
                var listDatas = new List<List<string>>();
                map[title] = listDatas;
                foreach (Match contextMatch in contextMatches)
                {
                    var listData = new List<string>();
                    listDatas.Add(listData);
                    var left = contextMatch.Groups["left"].Value.TrimStart().TrimEnd();
                    var right = contextMatch.Groups["right"].Value;
                    var lefts = left.Split(" ");
                    var temStr = string.Empty;
                    var temIndex = 0;
                    listData.Add(right);
                    for (int i = lefts.Length - 1; i >= 0; i--)
                    {
                        var v = lefts[i];
                        if (temIndex == 0)
                        {
                            temStr += $"{v}?:";
                            listData.Add(v);
                        }
                        else if (temIndex == 1)
                        {
                            temStr += TsParse.GetType(v);
                            if (EnumHash.Contains(v))
                            {
                                listData.Add("5");
                            }
                            else
                            {
                                listData.Add(TsParse.GetId(v));
                            }
                        }
                        else if (temIndex == 2)
                        {
                            switch (v)
                            {
                                case "repeated":
                                    temStr += "[]";
                                    listData.Add("1");
                                    break;
                                case "required":
                                    temStr = temStr.Replace("?", "");
                                    break;
                                case "optional":
                                    break;
                            }
                        }
                        temIndex++;
                    }
                    wd.Writeln($"{temStr};");
                }
                wd.EndBlock();
            }
            return true;
        }
    }
}
